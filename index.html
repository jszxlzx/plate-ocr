<!doctype html>
<html lang="zh-HK">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>車牌 OCR 快捷工具</title>
<style>
  body{font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:18px; max-width:820px;}
  h1{font-size:1.4rem}
  .card{border:1px solid #e4e4e4;border-radius:12px;padding:12px;margin-top:12px}
  label{display:block;margin:8px 0 6px;font-weight:600}
  button,input[type=file]{padding:10px;border-radius:8px;border:1px solid #ccc;background:#fff}
  #canvas{max-width:100%;border:1px dashed #ddd;margin-top:8px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .muted{color:#666;font-size:0.9rem;margin-top:6px}
  .result{white-space:pre-wrap;margin-top:10px;font-weight:700}
  .small{font-size:0.9rem;color:#555}
</style>
</head>
<body>
  <h1>車牌 OCR（iPhone 可拍照）</h1>
  <p class="muted">拍一張清晰車牌 → 裁切/調整 → 按「辨識」→ 複製/存入備忘錄</p>

  <div class="card">
    <label>步驟 1：拍照或選圖</label>
    <input id="file" type="file" accept="image/*" capture="environment" />
    <div class="muted small">按「拍照/選擇」後可在 iPhone 上直接拍攝（capture 屬性會叫出後置鏡頭）</div>

    <label>步驟 2：預覽 & 手動裁切（拖動矩形）</label>
    <canvas id="canvas"></canvas>

    <div class="controls">
      <button id="autoEnh">自動增強（對比 + 銳利）</button>
      <button id="toBW">二值化（黑白）</button>
      <button id="reset">重設</button>
      <button id="recognize">辨識（OCR）</button>
      <button id="copyBtn">複製文字</button>
      <button id="download">下載影像</button>
    </div>

    <div id="status" class="muted"></div>
    <div id="out" class="result"></div>
    <div class="muted small" style="margin-top:10px">
      建議：盡量直拍、保持平行、充足光線、只含一張車牌（距離不要太遠）。如需更高準確度，可使用 Google Vision / ML Kit（需 API）。
    </div>
  </div>

  <!-- Tesseract CDN -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>

  <script>
  // Basic canvas image loader + simple crop box
  const fileEl = document.getElementById('file');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let img = new Image();
  let imgW=0,imgH=0;
  let crop = {x:0,y:0,w:0,h:0,drag:false,resize:false};
  let scale=1;

  function fitCanvasTo(imgW,imgH){
    const maxW = Math.min(window.innerWidth-40, 720);
    scale = Math.min(1, maxW / imgW);
    canvas.width = Math.round(imgW * scale);
    canvas.height = Math.round(imgH * scale);
  }

  function drawImageAndOverlay(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0, imgW*scale, imgH*scale);
    if (crop.w && crop.h){
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 2;
      ctx.strokeRect(crop.x, crop.y, crop.w, crop.h);
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      // darken outside
      ctx.beginPath();
      ctx.rect(0,0,canvas.width,canvas.height);
      ctx.rect(crop.x,crop.y,crop.w,crop.h);
      ctx.fill('evenodd');
    }
  }

  fileEl.addEventListener('change', e=>{
    const f = e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    img = new Image();
    img.onload = ()=>{
      imgW = img.naturalWidth; imgH = img.naturalHeight;
      fitCanvasTo(imgW,imgH);
      // default crop = center small box
      crop.w = canvas.width*0.6; crop.h = canvas.height*0.18;
      crop.x = (canvas.width-crop.w)/2; crop.y = (canvas.height-crop.h)/2;
      drawImageAndOverlay();
      URL.revokeObjectURL(url);
    }
    img.src = url;
  });

  // simple mouse/touch handlers for moving crop
  let start = {};
  function posFromEvent(ev){
    const rect = canvas.getBoundingClientRect();
    const e = ev.touches ? ev.touches[0] : ev;
    return {x: e.clientX - rect.left, y: e.clientY - rect.top};
  }
  canvas.addEventListener('pointerdown', (ev)=>{
    const p = posFromEvent(ev);
    start = p;
    if (p.x > crop.x && p.x < crop.x+crop.w && p.y>crop.y && p.y<crop.y+crop.h){
      crop.drag = true;
    } else {
      // click outside: set new crop center
      crop.x = Math.max(0, p.x - crop.w/2);
      crop.y = Math.max(0, p.y - crop.h/2);
    }
    drawImageAndOverlay();
  });
  window.addEventListener('pointermove', (ev)=>{
    if (!crop.drag) return;
    const p = posFromEvent(ev);
    const dx = p.x - start.x, dy = p.y - start.y;
    start = p;
    crop.x = Math.min(Math.max(0, crop.x + dx), canvas.width - crop.w);
    crop.y = Math.min(Math.max(0, crop.y + dy), canvas.height - crop.h);
    drawImageAndOverlay();
  });
  window.addEventListener('pointerup', ()=>{ crop.drag = false; });

  // Image processing helpers
  function getCroppedImageData(){
    const sx = Math.round(crop.x/scale), sy = Math.round(crop.y/scale);
    const sw = Math.round(crop.w/scale), sh = Math.round(crop.h/scale);
    const tmp = document.createElement('canvas');
    tmp.width = sw; tmp.height = sh;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(img, sx, sy, sw, sh, 0,0, sw, sh);
    return tmp;
  }

  document.getElementById('autoEnh').addEventListener('click', ()=>{
    const tmp = getCroppedImageData();
    const tctx = tmp.getContext('2d');
    let d = tctx.getImageData(0,0,tmp.width,tmp.height);
    // simple contrast stretch
    for(let i=0;i<d.data.length;i+=4){
      let r=d.data[i], g=d.data[i+1], b=d.data[i+2];
      let lum = 0.299*r+0.587*g+0.114*b;
      lum = ((lum-128)*1.4)+128;
      d.data[i]=d.data[i+1]=d.data[i+2]=Math.max(0,Math.min(255,lum));
    }
    tctx.putImageData(d,0,0);
    img = new Image();
    img.src = tmp.toDataURL();
    img.onload = ()=>{
      imgW = img.width; imgH = img.height;
      fitCanvasTo(imgW,imgH);
      crop.w = canvas.width; crop.h = canvas.height;
      crop.x=0; crop.y=0;
      drawImageAndOverlay();
    };
  });

  document.getElementById('toBW').addEventListener('click', ()=>{
    const tmp = getCroppedImageData();
    const tctx = tmp.getContext('2d');
    let d = tctx.getImageData(0,0,tmp.width,tmp.height);
    // simple threshold using mean luminance
    let sum=0; for(let i=0;i<d.data.length;i+=4){ sum+= (0.299*d.data[i]+0.587*d.data[i+1]+0.114*d.data[i+2]); }
    const mean = sum / (d.data.length/4);
    for(let i=0;i<d.data.length;i+=4){
      let lum = 0.299*d.data[i]+0.587*d.data[i+1]+0.114*d.data[i+2];
      let v = lum > mean ? 255 : 0;
      d.data[i]=d.data[i+1]=d.data[i+2]=v;
    }
    tctx.putImageData(d,0,0);
    img = new Image();
    img.src = tmp.toDataURL();
    img.onload = ()=>{
      imgW = img.width; imgH = img.height;
      fitCanvasTo(imgW,imgH);
      crop.w = canvas.width; crop.h = canvas.height;
      crop.x=0; crop.y=0;
      drawImageAndOverlay();
    };
  });

  document.getElementById('reset').addEventListener('click', ()=>{
    if (!fileEl.files[0]) return;
    const url = URL.createObjectURL(fileEl.files[0]);
    img = new Image();
    img.onload = ()=>{
      imgW = img.naturalWidth; imgH = img.naturalHeight;
      fitCanvasTo(imgW,imgH);
      crop.w = canvas.width*0.6; crop.h = canvas.height*0.18;
      crop.x = (canvas.width-crop.w)/2; crop.y = (canvas.height-crop.h)/2;
      drawImageAndOverlay();
      URL.revokeObjectURL(url);
    }
    img.src = url;
  });

  const status = document.getElementById('status');
  const out = document.getElementById('out');

  document.getElementById('recognize').addEventListener('click', async ()=>{
    status.textContent = '開始辨識，請稍候……';
    out.textContent = '';
    const tmp = getCroppedImageData();
    tmp.toBlob(async blob=>{
      try{
        const worker = Tesseract.createWorker({
          logger: m => status.textContent = (m.status === 'recognizing text') ? `辨識中: ${Math.round(m.progress*100)}%` : m.status
        });
        await worker.load();
        await worker.loadLanguage('eng');
        await worker.initialize('eng');
        await worker.setParameters({
          tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 -',
          preserve_interword_spaces: '1'
        });
        const { data: { text } } = await worker.recognize(blob);
        await worker.terminate();
        let t = text.toUpperCase().replace(/[^\dA-Z\- ]+/g,'').replace(/\s{2,}/g,' ').trim();
        let tokens = t.split(/\s+/).filter(Boolean);
        let plate = tokens.length ? tokens[0] : t;
        out.textContent = plate || '[未能讀取]';
        status.textContent = '完成';
      }catch(err){
        status.textContent = '辨識失敗：' + (err.message||err);
      }
    }, 'image/png', 0.92);
  });

  document.getElementById('copyBtn').addEventListener('click', async ()=>{
    const txt = out.textContent || '';
    if (!txt) { alert('目前沒有辨識文字。'); return; }
    try{
      await navigator.clipboard.writeText(txt);
      alert('已複製到剪貼簿，請在備忘錄貼上 (Notes)。');
    }catch(e){
      const ta = document.createElement('textarea'); ta.value = txt; document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand('copy'); alert('已複製到剪貼簿'); }catch(e){ alert('複製失敗，請手動長按複製'); }
      ta.remove();
    }
  });

  document.getElementById('download').addEventListener('click', ()=>{
    const link = document.createElement('a');
    link.download = 'plate.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  canvas.width = Math.min(window.innerWidth-40, 640);
  canvas.height = canvas.width * 0.45;
  ctx.fillStyle = '#f8f8f8';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#888';
  ctx.fillText('請按「拍照/選擇」然後拖動綠色框選車牌位置', 12, 20);
  </script>
</body>
</html>
