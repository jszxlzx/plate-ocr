<!doctype html>
<html lang="zh-HK">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>è»Šç‰Œ OCR é€²éšç‰ˆï¼ˆOpenCV + Tesseract, ç›¸æ©Ÿ/ç›¸ç°¿, é€²åº¦é¡¯ç¤ºï¼‰</title>
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<style>
  :root{--border:#e4e4e4;--muted:#666;--accent:#0a7b12}
  body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial;margin:18px;max-width:920px}
  h1{font-size:1.4rem;margin:0 0 6px}
  .card{border:1px solid var(--border);border-radius:12px;padding:12px;margin-top:12px}
  label{display:block;margin:8px 0 6px;font-weight:600}
  button{padding:10px 12px;border-radius:10px;border:1px solid #ccc;background:#fff}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  #canvas,#proc{max-width:100%;border:1px dashed #ddd;margin-top:8px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .muted{color:var(--muted);font-size:0.92rem;margin-top:6px}
  .result{white-space:pre-wrap;margin-top:10px;font-weight:700;font-size:1.1rem}
  .ok{color:#0a7b12}.warn{color:#9a6700}.err{color:#b10000}
  .pill{display:inline-block;border:1px solid var(--border);border-radius:999px;padding:4px 10px;margin-right:6px;font-size:0.86rem}
  .row2{display:flex;gap:8px;flex-wrap:wrap}
  .barwrap{position:relative;background:#f3f3f3;border:1px solid #e5e5e5;border-radius:10px;height:12px;overflow:hidden}
  .bar{position:absolute;left:0;top:0;height:100%;width:0%;background:linear-gradient(90deg,#2ecc71,#27ae60)}
  .bartext{font-size:0.88rem;margin-top:4px;color:#333}
</style>
</head>
<body>
  <h1>è»Šç‰Œ OCR é€²éšç‰ˆï¼ˆç›¸æ©Ÿ / ç›¸ç°¿ï¼‰</h1>
  <div class="card">
    <label>æ¨¡å‹è¼‰å…¥é€²åº¦</label>
    <div class="barwrap"><div id="modelBar" class="bar"></div></div>
    <div id="modelTxt" class="bartext">åˆå§‹åŒ–ä¸­â€¦</div>
  </div>

  <div class="card">
    <div class="row">
      <div>
        <label>æ­¥é©Ÿ 1ï¼šæ‹ç…§æˆ–é¸åœ–</label>
        <div class="row2">
          <button id="btnCamera">ğŸ“¸ æ‹ç…§ä¸Šè¼‰</button>
          <button id="btnAlbum">ğŸ–¼ï¸ å¾ç›¸ç°¿é¸æ“‡</button>
        </div>
        <input id="inCamera" type="file" accept="image/*" capture="environment" style="display:none" />
        <input id="inAlbum" type="file" accept="image/*" style="display:none" />
        <div class="muted">æ‹æ”æ™‚ç›¡é‡æ­£é¢ã€å…‰ç·šå……è¶³ã€è»Šç‰Œæ©«å‘ä½”ç•«é¢ 40% ä»¥ä¸Šã€‚</div>
      </div>
      <div>
        <span class="pill">æµç¨‹ï¼šç°éš â†’ ç­‰åŒ– â†’ å»å™ª â†’ è‡ªé©æ‡‰äºŒå€¼åŒ– â†’ æ”¾å¤§ â†’ å½¢æ…‹å­¸</span>
        <div class="muted">å¦‚éœ€å¯æ‹–å‹•ç¶ æ¡†è£åˆ‡ã€‚</div>
      </div>
    </div>

    <label>åŸåœ– / è£åˆ‡</label>
    <canvas id="canvas"></canvas>

    <label>è™•ç†å¾Œï¼ˆOpenCV é è¦½ï¼‰<span id="procTag" class="muted"></span></label>
    <canvas id="proc"></canvas>

    <div class="controls">
      <button id="autocrop">è‡ªå‹•å®šä½è»Šç‰Œ</button>
      <button id="enhance">è™•ç†ä¸¦è¾¨è­˜</button>
      <button id="recognizeRaw">ç›´æ¥è¾¨è­˜ï¼ˆä¸è™•ç†ï¼‰</button>
      <button id="copy">è¤‡è£½çµæœ</button>
      <button id="reset">é‡è¨­</button>
    </div>

    <div id="status" class="muted">åˆå§‹åŒ–ä¸­â€¦</div>
    <div id="out" class="result"></div>
    <div class="muted" style="margin-top:8px">
      å¸¸è¦‹èª¤è®€è‡ªå‹•æ›´æ­£ï¼š<code>Oâ†”0</code>ã€<code>I/Lâ†”1</code>ã€<code>Bâ†”8</code>ã€<code>Sâ†”5</code>ã€‚é¦™æ¸¯å¸¸è¦‹æ ¼å¼ï¼š<code>^[A-Z]{1,3}\s?\d{1,4}$</code>ï¼ˆä¾‹å¦‚ <b>WV 7850</b>ï¼‰ã€‚
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.9.0-1/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>

<script>
const inCamera = document.getElementById('inCamera');
const inAlbum = document.getElementById('inAlbum');
const btnCamera = document.getElementById('btnCamera');
const btnAlbum = document.getElementById('btnAlbum');

const modelBar = document.getElementById('modelBar');
const modelTxt = document.getElementById('modelTxt');

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const proc = document.getElementById('proc');
const pctx = proc.getContext('2d');
const statusEl = document.getElementById('status');
const outEl = document.getElementById('out');
const procTag = document.getElementById('procTag');

let img = new Image();
let imgW=0,imgH=0, scale=1;
let crop = {x:0,y:0,w:0,h:0,drag:false};
let opencvReady = false;
let fallbackMode = false;

btnCamera.onclick = ()=> inCamera.click();
btnAlbum.onclick = ()=> inAlbum.click();

[inCamera, inAlbum].forEach(inp => {
  inp.addEventListener('change', e=>{
    const f=e.target.files[0]; if(!f) return;
    const url = URL.createObjectURL(f);
    img = new Image();
    img.onload = ()=>{
      imgW=img.naturalWidth; imgH=img.naturalHeight;
      scale = fitCanvasTo(imgW,imgH,canvas);
      crop.w = canvas.width*0.7; crop.h = canvas.height*0.22;
      crop.x = (canvas.width-crop.w)/2; crop.y=(canvas.height-crop.h)/2;
      drawOverlay();
      URL.revokeObjectURL(url);
      statusEl.textContent = 'å½±åƒå·²è¼‰å…¥ï¼Œæ‹–ç¶ æ¡†è‡³è»Šç‰Œï¼Œç„¶å¾ŒæŒ‰ã€Œè™•ç†ä¸¦è¾¨è­˜ã€æˆ–ã€Œç›´æ¥è¾¨è­˜ã€ã€‚';
      pctx.clearRect(0,0,proc.width,proc.height);
      outEl.textContent='';
    };
    img.src = url;
  });
});

function fitCanvasTo(w,h, el){
  const maxW = Math.min(window.innerWidth-40, 860);
  const s = Math.min(1, maxW / w);
  el.width = Math.round(w*s);
  el.height = Math.round(h*s);
  return s;
}
function drawOverlay(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img,0,0,imgW*scale,imgH*scale);
  if(crop.w>0 && crop.h>0){
    ctx.strokeStyle='lime';ctx.lineWidth=2;ctx.strokeRect(crop.x,crop.y,crop.w,crop.h);
    ctx.fillStyle='rgba(0,0,0,0.25)';
    ctx.beginPath();ctx.rect(0,0,canvas.width,canvas.height);ctx.rect(crop.x,crop.y,crop.w,crop.h);ctx.fill('evenodd');
  }
}
canvas.addEventListener('pointerdown', ev=>{
  const r=canvas.getBoundingClientRect(); const x=ev.clientX-r.left, y=ev.clientY-r.top;
  if (x>crop.x && x<crop.x+crop.w && y>crop.y && y<crop.y+crop.h){ crop.drag=true; }
});
window.addEventListener('pointermove', ev=>{
  if(!crop.drag) return;
  const r=canvas.getBoundingClientRect(); const x=ev.clientX-r.left, y=ev.clientY-r.top;
  crop.x = Math.min(Math.max(0, x-crop.w/2), canvas.width-crop.w);
  crop.y = Math.min(Math.max(0, y-crop.h/2), canvas.height-crop.h);
  drawOverlay();
});
window.addEventListener('pointerup', ()=>{ crop.drag=false; });

function getCropCanvas(){
  const sx = Math.round(crop.x/scale), sy = Math.round(crop.y/scale);
  const sw = Math.round(crop.w/scale), sh = Math.round(crop.h/scale);
  const tmp = document.createElement('canvas');
  tmp.width = sw; tmp.height = sh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(img, sx,sy,sw,sh, 0,0,sw,sh);
  return tmp;
}

function postFixPlate(t){
  let s = t.toUpperCase().replace(/[^A-Z0-9 ]+/g,' ').replace(/\s+/g,' ').trim();
  s = s.replace(/\b0([A-Z])/g,'O$1').replace(/\bO(\d)/g,'0$1');
  s = s.replace(/\b1([A-Z])/g,'I$1').replace(/\bI(\d)/g,'1$1');
  s = s.replace(/B(?=\d)/g,'8').replace(/(?<=\D)8(?=\d)/g,'B');
  s = s.replace(/S(?=\d)/g,'5').replace(/(?<=\D)5(?=\d)/g,'S');
  const tokens = s.split(' ');
  const plateRe = /^[A-Z]{1,3}\s?\d{1,4}$/;
  let best = '';
  for(const tok of tokens){
    const t2 = tok.length>3 ? tok.slice(0,8) : tok;
    if (plateRe.test(t2)) return t2.replace(/(\D)(\d)/,'$1 $2');
    if(t2.length>best.length) best=t2;
  }
  return best;
}

async function runTesseractFromCanvas(cnv, hint=''){
  const blob = await new Promise(res=>cnv.toBlob(b=>res(b),'image/png',0.92));
  const worker = Tesseract.createWorker({
    logger: m => {
      if(m.status==='recognizing text'){
        const p = Math.round(m.progress*100);
        modelTxt.textContent = 'OCR ' + p + '%';
        modelBar.style.width = p + '%';
      }
    }
  });
  await worker.load(); await worker.loadLanguage('eng'); await worker.initialize('eng');
  await worker.setParameters({ tessedit_char_whitelist:'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ', preserve_interword_spaces:'1' });
  const {data:{text}} = await worker.recognize(blob);
  await worker.terminate();
  return postFixPlate(text);
}

function opencvProcess(srcCanvas){
  const src = cv.imread(srcCanvas);
  let mat = new cv.Mat(); cv.cvtColor(src, mat, cv.COLOR_RGBA2GRAY);
  cv.equalizeHist(mat, mat);
  cv.GaussianBlur(mat, mat, new cv.Size(3,3), 0, 0, cv.BORDER_DEFAULT);
  let th = new cv.Mat();
  cv.adaptiveThreshold(mat, th, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 31, 5);
  let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2,2));
  cv.morphologyEx(th, th, cv.MORPH_CLOSE, kernel);
  let big = new cv.Mat();
  cv.resize(th, big, new cv.Size(0,0), 2, 2, cv.INTER_CUBIC);
  cv.imshow('proc', big);
  src.delete(); mat.delete(); th.delete(); kernel.delete();
  return big;
}

async function enhanceAndRecognize(){
  if(!inCamera.files[0] && !inAlbum.files[0]){ alert('è«‹å…ˆä¸Šè¼‰æˆ–æ‹ç…§'); return; }
  const cropCnv = getCropCanvas();
  if (fallbackMode || !opencvReady) {
    modelTxt.textContent = 'è¼•é‡æ¨¡å¼ OCR ä¸­â€¦'; modelBar.style.width = '10%';
    const text = await runTesseractFromCanvas(cropCnv, 'ï¼ˆè¼•é‡æ¨¡å¼ï¼‰');
    showResult(text, false);
  } else {
    statusEl.textContent='OpenCV è™•ç†ä¸­â€¦';
    modelTxt.textContent='OpenCV è™•ç†â€¦'; modelBar.style.width='20%';
    let big = opencvProcess(cropCnv);
    const outCnv = document.createElement('canvas');
    outCnv.width = big.cols; outCnv.height = big.rows;
    cv.imshow(outCnv, big); big.delete();
    const text = await runTesseractFromCanvas(outCnv, 'ï¼ˆOpenCV è™•ç†å¾Œï¼‰');
    showResult(text, true);
  }
}
function showResult(text, usedOpenCV){
  modelBar.style.width = '100%'; modelTxt.textContent = 'å®Œæˆ 100%';
  if(text){
    outEl.innerHTML = 'çµæœï¼š<span class="ok">'+text+'</span>' + (usedOpenCV?'':' <span class="muted">ï¼ˆè¼•é‡æ¨¡å¼ï¼‰</span>');
    statusEl.textContent = usedOpenCV ? 'å®Œæˆï¼ˆOpenCV + OCRï¼‰' : 'å®Œæˆï¼ˆåƒ… OCRï¼‰';
  }else{
    outEl.innerHTML = '<span class="warn">æœªèƒ½è®€å–ï¼Œè«‹èª¿æ•´æ¡†é¸æˆ–é è¿‘å†æ‹ã€‚</span>';
    statusEl.textContent='æœªèƒ½è®€å–';
  }
}

document.getElementById('enhance').onclick = enhanceAndRecognize;

document.getElementById('recognizeRaw').onclick = async ()=>{
  if(!inCamera.files[0] && !inAlbum.files[0]){ alert('è«‹å…ˆä¸Šè¼‰æˆ–æ‹ç…§'); return; }
  modelTxt.textContent='OCR æº–å‚™ä¸­â€¦'; modelBar.style.width='10%';
  const cropCnv = getCropCanvas();
  const text = await runTesseractFromCanvas(cropCnv, 'ï¼ˆåŸåœ–ï¼‰');
  showResult(text, false);
};

document.getElementById('reset').onclick = ()=>{
  [inCamera, inAlbum].forEach(i=>i.value='');
  initCanvas();
  pctx.clearRect(0,0,proc.width,proc.height);
  outEl.textContent='';
  statusEl.textContent='å·²é‡è¨­';
  modelBar.style.width='0%'; modelTxt.textContent='åˆå§‹åŒ–ä¸­â€¦';
};

document.getElementById('autocrop').onclick = ()=>{
  crop.w = canvas.width*0.8; crop.h = canvas.height*0.2;
  crop.x = (canvas.width-crop.w)/2; crop.y = (canvas.height-crop.h)/2;
  drawOverlay();
};

function initCanvas(){
  canvas.width = Math.min(window.innerWidth-40, 800);
  canvas.height = Math.round(canvas.width*0.6);
  ctx.fillStyle='#f6f6f6'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#777'; ctx.fillText('ä¸Šè¼‰ç›¸ç‰‡æˆ–æ‹ç…§ â†’ ç¶ æ¡†åœˆä½è»Šç‰Œ â†’ æŒ‰ã€Œè™•ç†ä¸¦è¾¨è­˜ã€æˆ–ã€Œç›´æ¥è¾¨è­˜ã€', 12, 20);
  proc.width = canvas.width; proc.height = Math.round(canvas.height*0.45);
}
initCanvas();

// === OpenCV è¼‰å…¥ç›£æ§ & é€²åº¦æ¢ï¼ˆæ¨¡æ“¬ï¼‰ & Fallback ===
procTag.textContent = 'ï¼ˆOpenCV é è¦½ï¼‰';
statusEl.textContent = 'æ­£åœ¨è¼‰å…¥æ¨¡å‹â€¦ï¼ˆé¦–æ¬¡ç´„ 20â€“40 ç§’ï¼‰';
let approx = 0;
const inc = ()=>{ approx = Math.min(approx+2, 90); modelBar.style.width = approx+'%'; modelTxt.textContent = 'è¼‰å…¥ä¸­â€¦ '+approx+'%'; };
let approxTimer = setInterval(inc, 700);

let loadTimer = setTimeout(()=>{
  if (!opencvReady){
    fallbackMode = true;
    clearInterval(approxTimer);
    modelBar.style.width='35%'; modelTxt.textContent = 'OpenCV è¼‰å…¥è¶…æ™‚ï¼Œåˆ‡æ›ã€Œè¼•é‡æ¨¡å¼ã€';
    procTag.textContent = 'ï¼ˆOpenCV æœªå°±ç·’ï¼Œç•¥éé è¦½ï¼‰';
  }
}, 40000);

if (window.cv){
  cv['onRuntimeInitialized'] = ()=>{
    opencvReady = true;
    clearTimeout(loadTimer); clearInterval(approxTimer);
    modelBar.style.width='100%'; modelTxt.textContent = 'OpenCV å·²å°±ç·’ 100%';
    statusEl.textContent = 'OpenCV å·²å°±ç·’ï¼Œå¯ç”¨ã€Œè™•ç†ä¸¦è¾¨è­˜ã€ç²è¼ƒé«˜æº–ç¢ºåº¦ã€‚';
    procTag.textContent = 'ï¼ˆOpenCV é è¦½ï¼‰';
  };
}
</script>
</body>
</html>
